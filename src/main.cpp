#include <iostream>
#include <string>
#include <cstdlib>
#include <vector>

#include "color.hpp"
#include "segment.hpp"

template<typename OutputIterator>
auto
printJoined(
        OutputIterator begin,
        OutputIterator const end,
        std::ostream& out,
        std::string const& delim)
    -> void
{
    if(begin == end) {
        return;
    }

    out << *begin;
    while(++begin != end) {
        out << delim << *begin;
    }
}

auto
printFunctions(std::ostream& out) -> void
{
    out << R"(/*** generated by ggr2glsl ***/
float ggr2glsl_linearFactor(float pos, float mid) {
    if(pos < mid) { return mix(0.0, 0.5, pos / mid); }
    
    return mix(0.5, 1.0, (pos - mid) / (1.0 - mid));
}

/*** generated by ggr2glsl ***/
vec4 ggr2glsl_hsv2rgb(vec4 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return vec4(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), c.a);
}

/*** generated by ggr2glsl ***/
vec4 ggr2glsl_rgb2hsv(vec4 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return
        vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x, c.a);
}
)";
}

auto
main() -> int
{
    Segments const segments = parseSegments(std::cin);
    
    std::cout.precision(5);
    std::cout.setf(std::ios::fixed);
    printFunctions(std::cout);
    std::cout << "/*** generated by ggr2glsl ***/\n";
    std::cout << "vec4 ggr2glsl_color(float value) {\n";
    std::cout << "    value = clamp(value, 0.0, 1.0);\n\n";

    auto const printData = [](
            auto const& data,
            std::string const& name,
            std::string const& type) {
        std::cout << "    const " << type << " " << name
            << "[" << data.size() << "] = " << 
            type << "[" << data.size() << "](\n";

        std::cout << "        ";
        printJoined(data.begin(), data.end(), std::cout, ",\n        ");

        std::cout << "\n    );\n\n";
    };

    printData(segments.left, "left", "float");
    printData(segments.middle, "middle", "float");
    printData(segments.right, "right", "float");
    printData(segments.leftColor, "leftColor", "vec4");
    printData(segments.rightColor, "rightColor", "vec4");
    printData(segments.blendType, "blendType", "int");
    printData(segments.colorType, "colorType", "int");

    std::cout
        << "    int first = 0;\n"
        << "    int last = " << segments.size()-1 << ";\n";

    std::cout <<
R"(
    while(first != last) {
        int i = (first+last) / 2;
        if(value <= right[i]) {
            last = i;
        }
        else {
            first = i + 1;
        }
    }
    int index = first;

    float length = right[index] - left[index];

    float mid = (middle[index] - left[index]) / length;
    float pos = (value - left[index]) / length;
    
    const float pi = 3.14159;
    float factor;
    switch(blendType[index]) {
    //linear
    case 0: {
        factor = ggr2glsl_linearFactor(pos, mid);
    }   break;

    //curved
    case 1: {
        factor = exp(-log2(pos) / log2(mid));
    }   break;

    //sinusoidal
    case 2: {
        float newPos = ggr2glsl_linearFactor(pos, mid);
        factor = 0.5 * (sin((pi * 0.5) + pi * newPos) + 1.0);
    }   break;

    //sherical (increasing)
    case 3: {
        float newPos = ggr2glsl_linearFactor(pos, mid);
        factor = sqrt(1.0 - newPos * newPos);
    }   break;

    //sherical (decreasing)
    case 4: {
        float newPos = ggr2glsl_linearFactor(pos, mid);
        factor = 1.0 - sqrt(1.0 - newPos * newPos);
    }   break;

    //step
    case 5: {
        factor = float(pos <= mid);
    }   break;
    }

    switch(colorType[index]) {
    //rgb
    case 0: {
        vec4 lGammaCorrected = pow(leftColor[index], vec4(1.0/2.2));
        vec4 rGammaCorrected = pow(rightColor[index], vec4(1.0/2.2));
        return pow(mix(lGammaCorrected, rGammaCorrected, factor), vec4(2.2));
    }   break;

    //hsv ccw
    case 1: {
        vec4 leftHsv = ggr2glsl_rgb2hsv(leftColor[index]);
        vec4 rightHsv = ggr2glsl_rgb2hsv(rightColor[index]);
        
        vec4 res = leftHsv;
        res.yzw = mix(leftHsv.yzw, rightHsv.yzw, factor);
        
        if(leftHsv.x < rightHsv.x) {
            res.x += factor * (rightHsv.x - leftHsv.x);
        }
        else {
            res.x += factor * (1.0 - (leftHsv.x - rightHsv.x));
        }

        if(res.x > 1.0) {
            res.x -= 1.0;
        }

        return ggr2glsl_hsv2rgb(mix(leftHsv, rightHsv, factor));
    }   break;

    //hsv cw
    case 2: {
        vec4 leftHsv = ggr2glsl_rgb2hsv(leftColor[index]);
        vec4 rightHsv = ggr2glsl_rgb2hsv(rightColor[index]);
        
        vec4 res = leftHsv;
        res.yzw = mix(leftHsv.yzw, rightHsv.yzw, factor);
        
        if(rightHsv.x < leftHsv.x) {
            res.x -= factor * (leftHsv.x - rightHsv.x);
        }
        else {
            res.x -= factor * (1.0 - (rightHsv.x - leftHsv.x));
        }

        if(res.x < 0.0) {
            res.x += 1.0;
        }

        return ggr2glsl_hsv2rgb(mix(leftHsv, rightHsv, factor));
    }   break;
    
    }
)";


    // Closing function bracket
    std::cout << "}\n";
}
